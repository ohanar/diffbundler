#!/usr/bin/env python

import os, shutil, subprocess, sys, tarfile, tempfile

REFSHEADS = os.path.join('refs', 'heads')
REFSTAGS = os.path.join('refs', 'tags')

def flattened_iter(*args):
    for arg in args:
        if hasattr(arg, '__iter__'):
            for a in flattened_iter(*arg):
                yield a
        else:
            yield arg

_curdir = None

def git_popen_unclean(directory, *args):
    global _curdir
    if _curdir != directory:
        os.chdir(directory)
        _curdir = directory
    ret = subprocess.Popen(flattened_iter('git', *args),
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return ret

def git_popen(directory, *args):
    args = tuple(args)
    ret = git_popen_unclean(directory, *args)
    if ret.wait():
        _, stderr = ret.communicate()
        print(stderr)
        raise RuntimeError("an error occurred running '%s'"%' '.join(
                flattened_iter('git', *args)))
    return ret

def git_retcode(*args):
    p = git_popen_unclean(*args)
    return p.wait()

def git_stdout(*args):
    p = git_popen(*args)
    stdout, _ = p.communicate()
    ret = tuple(bt.decode('utf-8') for bt in stdout.splitlines())
    if len(ret) == 1:
        return ret[0]
    else:
        return ret

def get_shas(refs_dir):
    ret = set()
    for f in ('HEAD', 'heads', 'tags'):
        try:
            f = open(f, 'r')
        except IOError:
            continue
        for l in f:
            ret.add(l.split(' ')[0])
        f.close()
    return ret

class DiffBundle(object):

    def __init__(self, path):
        self.path = path
        # the only time we are allowed to write
        # is if we are creating a new DiffBundle
        self.read_only = os.path.isfile(path)
        if self.read_only:
            self._tarf = tarfile.open(self.path, 'r')
        else:
            self._tarf = tarfile.open(self.path, 'w')

    def extract(self, extract_dir):
        try:
            tari = self._tarf.getmember('bundle')
        except KeyError:
            return
        tmpd = tempfile.mkdtemp()
        try:
            self._tarf.extract(tari, tmpd)
            git_popen(extract_dir, 'bundle', 'unbundle',
                    os.path.join(tmpd, tari.name))
        finally:
            shutil.rmtree(tmpd)

    def extract_refs(self, extract_dir):
        try:
            tari = self._tarf.getmember('refs')
        except KeyError:
            return
        tmpd = tempfile.mkdtemp()
        try:
            self._tarf.extract(tari, tmpd)
            git_popen(extract_dir, 'checkout',
                    git_stdout(extract_dir, 'bundle', 'unbundle',
                        os.path.join(tmpd, tari.name)).split(' ')[0])
        finally:
            shutil.rmtree(tmpd)

class DiffBundler(object):

    def __init__(self, bundle_dir):
        self.bundle_dir = bundle_dir
        self._bundles = {}

    def __len__(self):
        try:
            return self._len
        except AttributeError:
            pass
        self._len = 0
        for f in os.listdir(self.bundle_dir):
            try:
                if f.endswith('.diffbundle'):
                    self._len = max(self._len, int(f[:-11])+1)
            except ValueError:
                pass
        return self._len

    def __getitem__(self, i):
        if not isinstance(i, int):
            raise TypeError('list indices must be integers')
        if i < 0:
            i += len(self)
        if i < 0 or i >= len(self):
            raise IndexError('list index out of range')
        try:
            return self._bundles[i]
        except KeyError:
            pass
        ret = self._bundles[i] = DiffBundle(
                os.path.join(self.bundle_dir, str(i)+'.diffbundle'))
        return ret

    def __iter__(self):
        for i in range(len(self)):
            yield self[i]

    def __nonzero__(self):
        return len(self)

    def extract(self, extract_dir):
        git_popen(extract_dir, 'init')
        for bundle in self:
            bundle.extract(extract_dir)
        tmpd = tempfile.mkdtemp()
        try:
            self._extract_refs(tmpd)
            os.chdir(extract_dir)
            f = open(os.path.join(tmpd, 'HEAD'), 'r')
            HEAD = f.read()
            git_popen(extract_dir, 'checkout', HEAD)
            for fn, cmd in (('tags', 'tag'), ('heads', 'branch')):
                f.close()
                f = open(os.path.join(tmpd, fn), 'r')
                for ref in f:
                    ref = ref.strip('\n')
                    sha, name = ref.split(' ')
                    git_popen(extract_dir, cmd, name, sha)
                    if HEAD == sha:
                        # try to checkout a branch if HEAD's sha matches
                        git_popen(extract_dir, 'checkout', name)
                f.close()
        finally:
            shutil.rmtree(tmpd)

    def _extract_refs(self, extract_dir):
        git_popen(extract_dir, 'init')
        for bundle in self:
            bundle.extract_refs(extract_dir)

    def create_diffbundle(self, repo_dir):
        tmpd = tempfile.mkdtemp()
        try:
            self._extract_refs(tmpd)
            old_shas = get_shas(tmpd)
            args = []
            HEADf = open(os.path.join(tmpd, 'HEAD'), 'w')
            headsf = open(os.path.join(tmpd, 'heads'), 'w')
            tagsf = open(os.path.join(tmpd, 'tags'), 'w')
            for ref in git_stdout(repo_dir, 'show-ref', '--head'):
                sha, name = ref.split(' ')
                if name == 'HEAD':
                    HEADf.write(sha)
                elif name.startswith(REFSHEADS):
                    name = name[len(REFSHEADS)+1:]
                    headsf.write(sha+' '+name+'\n')
                elif name.startswith(REFSTAGS):
                    name = name[len(REFSTAGS)+1:]
                    tagsf.write(sha+' '+name+'\n')
                m = -1
                for old_sha in old_shas:
                    tmb = git_stdout(repo_dir, 'merge-base', old_sha, sha)
                    tm = len(git_stdout(repo_dir,
                            'rev-list', tmb+'..'+sha))
                    if m < 0 or tm < m:
                        merge_base = tmb
                        m = tm
                        if not m:
                            break
                if m > 0:
                    args.append(merge_base+'..'+name)
            HEADf.close()
            headsf.close()
            tagsf.close()

            if not self:
                args = '--all'

            bundle = bool(args)

            refs = bool(git_retcode(tmpd, 'diff', '--quiet'))

            if not (bundle or refs):
                raise ValueError('there were no changes in the repository')

            if bundle:
                git_popen(repo_dir, 'bundle', 'create',
                        os.path.join(tmpd, 'bundle'), args)

            if refs:
                git_popen(tmpd, 'add', 'HEAD', 'heads', 'tags')
                git_popen(tmpd, 'commit', "--message='%s.diffbundle"%len(self))
                if not self:
                    git_popen(tmpd, 'checkout',
                            git_stdout(tmpd, 'show-ref', '--hash'))
                    git_popen(tmpd, 'branch', '--delete', 'master')
                arg = 'HEAD^..HEAD' if self else '--all'
                git_popen(tmpd, 'bundle', 'create', 'refs', arg)
            new_bundle_path = os.path.join(
                    self.bundle_dir, str(len(self))+'.diffbundle')
            try:
                tarf = tarfile.open(new_bundle_path, 'w')
                if bundle:
                    tarf.add('bundle')
                if refs:
                    tarf.add('refs')
                tarf.close()
            except:
                try:
                    os.remove(new_bundle_path)
                except:
                    pass
                raise
            self._len = len(self) + 1
        finally:
            shutil.rmtree(tmpd)

if sys.argv[1] == 'new':
    DB = DiffBundler(os.path.realpath(sys.argv[3]))
    DB.create_diffbundle(os.path.realpath(sys.argv[2]))
elif sys.argv[1] == 'extract':
    DB = DiffBundler(os.path.realpath(sys.argv[2]))
    DB.extract(os.path.realpath(sys.argv[3]))
